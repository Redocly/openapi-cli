/* eslint-disable no-underscore-dangle */

class RegRule {
  static get rule() {
    return 'reg-rule';
  }

  constructor(config) {
    this.ruleSets = {};

    for (const ruleName of Object.keys(config.rules || {})) {
      const [treeLevel, field] = config.rules[ruleName].on.split('.');
      const rule = {
        not: false,
        ...config.rules[ruleName],
        treeLevel,
        field,
        name: ruleName,
      };

      const regexp = (!!rule.regexp && new RegExp(rule.regexp)) || null;
      const startsWith = (!!rule.startsWith && new RegExp(`^${rule.startsWith}`)) || null;
      const endsWith = (!!rule.endsWith && new RegExp(`${rule.endsWith}$`)) || null;

      const checkForRegexp = (node, ctx, expr, inverse) => {
        if ((!inverse && !node[rule.field].match(expr)) || (inverse && node[rule.field].match(expr))) {
          ctx.path.push(rule.field);
          const error = ctx.createError(rule.message || `Error was generated by ${rule.name} validation rule.`, 'value');
          ctx.path.pop();
          return error;
        }
        return null;
      };

      const validateRule = (node, ctx) => {
        let error = null;
        if (regexp) {
          error = error || checkForRegexp(node, ctx, regexp, rule.not);
        }
        if (startsWith) {
          error = error || checkForRegexp(node, ctx, startsWith, rule.not);
        }
        if (endsWith) {
          error = error || checkForRegexp(node, ctx, endsWith, rule.not);
        }

        return error;
      };

      rule.validate = validateRule;

      if (!this.ruleSets[rule.treeLevel]) {
        this.ruleSets[rule.treeLevel] = [];
      }

      this.ruleSets[rule.treeLevel].push(rule);
    }
  }

  any() {
    return {
      onExit: (node, definition, ctx) => {
        if (!this.ruleSets[definition.name]) return [];
        const errors = [];
        for (const rule of this.ruleSets[definition.name]) {
          const validationResult = rule.validate(node, ctx);
          if (validationResult) errors.push(validationResult);
        }
        return errors;
      },
    };
  }
}

module.exports = RegRule;
